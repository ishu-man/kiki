"""
Django settings for kiki project.

Generated by 'django-admin startproject' using Django 5.2.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-@w$gwm1betxjkmd2*@0fqtfsgktb%dqp=o-@p0fj0&uaw4o-!v'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

CORS_ALLOW_ALL_ORIGINS = True # This is perhaps the most UNSAFE thing in this file..

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'corsheaders',
    'engine',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'kiki.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'kiki.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'kikidb',
        'USER': 'postgres',
        'PASSWORD': 'Ishuman_07',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}

# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

CSRF_TRUSTED_ORIGINS = ['http://localhost:8000', 'https://9cdebed02543.ngrok-free.app']


"""
# 1. Create a new postgres database and connect it to this django project.
# 2. Create a new app (what will you name it?) and work inside its models.py
# 3. Define the model for cards. What properties do the cards have? Front/back/due/UID?
# 4. Create an API view from where you can read/write into that card data.
# 5. Use a serializer to serialize the card data. 



I have created 2 API views -> One GETs you all the cards (list API view) present in the database. What will I have to do with this API view?
Clearly, I have to have a CREATE API VIEW for me to POST all the cards from the gemini response that I have written in a script.
so for now, 
# 1. Create a CreateAPIView that lets you POST the card data as JSON. I will reformat the gemini JSON format (it should include pk field and due time)
# 2. Write a script that converts gemini's response to a valid JSON. Test it so that if due is not present it's automatically "now".
# 3. Write a script that takes gemini's validated JSON response and POSTs it to your create api view.

if you do all of that you will have successfully completed one of the 4 major pipelines in this project. The pipelines are,

# 1. User form data to backend and that info to gemini
2. ElevenLabs' audio to frontend.
# 3. Gemini's JSON to valid flashcards sent to the frontend -- WORKING ON THIS!!!
4. User's response on those flashcards to the backend (create a python script that converts those responses into fsrs friendly data)
5. FSRS algo gives you due datetimes and you update (PUT) the flashcards from an update view.

# Let's tackle user form data to backend now. I create a valid JSON from user form data using javascript. Now I need an API endpoint where
# I can POST that valid JSON. This is your second task: Create another ListCreateAPIView where javascript can POST the user's form data.
# Now GET this form data using a python client and use those values to properly prompt gemini about what to do next.

ElevenLabs' audio to frontend is done!! I just need to create a new user and generate a new API KEY as I have exhausted almost all of my
credits.

The final pipeline: FSRS algo gives you due datetimes... will be tackled after you do all of the above. First start with the gemini response
to JSON and an API view to POST that data which can be FETCHed by the frontend.






6. What API endpoints do you need? One is for retrieving all cards using GET. Another use would be POST-ing the user's responses into 
    an endpoint. Can this be a read/write endpoint? I need the fsrs engine to decide what the due time is. I need to create at least
    two endpoints. One can be a GET endpoint for retrieving the cards. Another has to be a POST endpoint from where I can POST user
    choices and use a python script to convert those to fsrs-friendly numbers.
7. As soon as you create an endpoint, test it by sending a fetch from the frontend.

"""